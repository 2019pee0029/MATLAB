// dtrans : iteratively computes the distance transform

/*   This file is part of a software package written by 
     Rainer Heintzmann
     Institute of Applied Optics and Information Processing
     Albert Ueberle Strasse 3-5
     69120 Heidelberg
     Tel.: ++49 (0) 6221  549264
     Current Address : Max Planck Inst. for Biophysical Chemistry, Am Fassberg 11, 37077 Goettingen, Germany
     Tel.: ++49 (0) 551 201 1029, e-mail: rheintz@gwdg.de  or rainer@heintzmann.de
     No garantee, whatsoever is given about functionallaty and  savety.
     No warranty is taken for any kind of damage it may cause.
     No support for it is provided !

     THIS IS NOT FREE SOFTWARE. All rights are reserved, and the software is only
     given to a limited number of persons for evaluation purpose !
     Please do not modify and/or redistribute this file or any other files, libraries
     object files or executables of this software package !
*/

#include <iostream>
#include <string>
#include "rawarray.h"
#include "parseargs.h"

typedef float ArrayBType;
typedef TArray3d<ArrayBType> TImgArray;

static TImgArray InputImg,DistTotal,DistX,DistY,DistZ;


void usage(char * filename)
{
  cerr <<  "usage: " << filename << " [-k] [-s number] [-t] [-i inputfile] [-o outputfile] \n" << flush;
  exit(-1);
}


int main(int argc, char *argv[])
{ 
int Elements=1,i;
static int INPUTSizeX=32;  // These is the standart size, if raw data is used
static int INPUTSizeY=32;  // 256
static int INPUTSizeZ=32;  // 22

int kflag=0;

string INPUTFileName,OUTDistFileName,OUTPUTFileName;

char ** parg= & argv[1];
argc=0;  // to prevent warning

 while (* parg)
  {
   if (readArg("-k",parg)) {kflag=1;continue;}
   if (readArg("-i", & INPUTFileName, parg)) continue;
   if (readArg("-od", & OUTDistFileName, parg)) continue;
   if (readArg("-ov", & OUTPUTFileName, parg)) continue;
   if (readArg("-sX",& INPUTSizeX, parg)) continue;
   if (readArg("-sY",& INPUTSizeY,parg)) continue;
   if (readArg("-sZ",& INPUTSizeZ,parg)) continue;
    usage(argv[0]);
  }

  ofstream tov(OUTPUTFileName.c_str());
  ofstream tod(OUTDistFileName.c_str());
      
  if (! tov )
    {
      cerr << "Couldn't open vector file " << OUTPUTFileName << " for writing !!\n" << flush;
      exit(-1);
    }

  if (! tod )
    {
      cerr << "Couldn't open distance file " << OUTDistFileName << " for writing !!\n" << flush;
      exit(-1);
    }
	  
  for (i=0;i<Elements;i++)
  {

  Elements=InputImg.DLoad(kflag,INPUTFileName.c_str(),"Float",
			  & INPUTSizeX,& INPUTSizeY,& INPUTSizeZ,i);

  if (i==0)
    {
      DistTotal.Resize(& InputImg);
      DistX.Resize(& InputImg);
      // DistX.Set(1e30);  // Huge value
      DistY.Resize(& InputImg);
      DistZ.Resize(& InputImg);

      if (kflag)
      {
	  if (kflag) WriteKhorosHeader(& tod,"Generated by dtrans","Float",INPUTSizeX,INPUTSizeY,INPUTSizeZ,Elements);
	  cerr << "writing file " << OUTDistFileName << " \n" << flush;
      // writes redistributed penalty image, and three vector images
	  if (kflag) WriteKhorosHeader(& tov,"Generated by dtrans","Float",INPUTSizeX,INPUTSizeY,INPUTSizeZ,Elements*4);
	  cerr << "writing file " << OUTPUTFileName << " \n" << flush;
      }
    }

    DistTotal.Copy(& InputImg);
    DistTotal.Sqr();
  
    InputImg.DTrans(DistTotal,DistX,DistY,DistZ);
    DistTotal.Sqrt(); 
    DistTotal.Write(& tov);
	
    InputImg.DTransFinalize(DistTotal,DistX,DistY,DistZ);  // adds the distances to the penalty in DistTotal
    DistTotal.Write(& tod);
    DistX.Write(& tov);
    DistY.Write(& tov);
    DistZ.Write(& tov);
  }
  tod.close();
  tov.close();
}
